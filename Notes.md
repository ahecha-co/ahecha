# Notes

## Blockers

- Routes: it seems that with macros we cannot get the function module path, so we might need to parse the api and pages folders in order to generate the routes.

## How it works

- `use_query!`: receives a route as first parameter and if the route has parameters it receives them as second argument as an object (example `use_query!(api::user::show, params = { id: userId })`), it will take the information from the route metadata and generate a callback that you later on can use to retrieve the results, also it will cancel other requests to the same route if called multiple times, so you ensure that there will be only one fetch instance. Also it will infer the return type from the route wrapped in an `Option`.
- ~~`path!`: same as `use_query!` but it will return the url string (example `path!(api::user::show, params = { id })`).~~
- `#{route_fn_name}_path` will replace the idea of `path!` and this function will be generated by the `proc_macro_attribute route`,
this will return the path as a str, the route params will be passed to the function as argument.
- `use_mutation!`: same as `use_query!` but the returned callback method will receive an object as an input that will be validated by the mutation request validator client side too and same as `use_query!` it will use the return type from the request, if any.
- `html!`: validates the html and the registered components (custom elements).

## Open questions

- How to implement `use_query!`/`path!`/`use_mutation!` macros, it is possible?
  - Explore the use of [gRPC](https://crates.io/crates/grpc)
  - `path!` will be replaced by a function generated with the `proc_macro_attribute`
- How to implement `html!` that supports html5 (`typed-html` like) and also a way to support the components/custom elements with SSR, it is possible?
  - Sauron seems an intersting alternative
- How to implement models with automigration generation use pure rust or go with a custom syntax (like prisma does)?
- Use an existing web framework as a base (example rocket) or build one on top of low level crates?

## Important resources

- [Reddit](https://www.reddit.com/r/rust/comments/q1vzsx/rust_web_frameworks_a_new_look_discussion/)

## View

- [Custom-Elements](https://github.com/gbj/custom-elements) something to check it out.

## Architecture

Split the app into multiple crates, example:

```bash
|- app
|  |- api
|  |  |- src
|  |  |- Cargo.toml
|  |  |  |- models="*"
|  |- pages
|  |  |- src
|  |  |- Cargo.toml
|  |  |  |- api="*"
|  |  |  |- models="*"
|  |- models
|  |  |- src
|  |  |- Cargo.toml
|- backend
|  |- src
|  |- Cargo.toml
|- frontend
|  |- src
|  |- Cargo.toml
```

Where backend and frontend passes the feature flags to api/pages/models/etc to limit the features shown,
fow example frontend doesn't need to show the source code of the route, just the path, and for the
models it need to expose only the barebone structs and validators, not the database connection and query.

Using like this will need a rework in the `proc_macro_attribute`, it will check for the crate name to
match `api` or `pages`.
